\documentclass{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage[parfill]{parskip}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}[section]
\newtheorem{claim}[theorem]{Claim}
\newtheorem{eg}{Example}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}{Remark}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\begin{document}	
\tableofcontents
\listofalgorithms
\section{Graphs}

\begin{definition}{Components}
	A component can be thought of as sub-graphs, where any two vertices are connected via a path. Components may have cycles. A graph that is itself connected has exactly one component.
	\href{https://en.wikipedia.org/wiki/Component_(graph_theory)}{Wiki}. 
\end{definition}

\subsection{Connected components, un-directed graphs}
\label{cc_und}

\begin{definition}{$cc$}
The number of current, connected component being explored. Each $v \in V$ belongs to a connected component identified by $cc$. It may be accessed or assigned via:
$$ccnum[v]$$
\end{definition}

\begin{algorithm}[H]
\caption{$DFS(G)$: Given vertices $V$ in graph $G$, find all strongly connected components.}
\label{alg:dfs_und}
\begin{algorithmic}[1]
\REQUIRE $G$ is an un-directed graph in adjacency-list form.
\STATE $cc \gets 0$
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
	\STATE $cc \gets cc + 1$
	\STATE $Explore(v)$ \COMMENT{Each time $Explore$ is called, a new connected component is picked out.}
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}[H]
\caption{$Explore(v)$: identifies the connected component containing $v$.}
\label{alg:dfs_und_exp}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\STATE $ccnum[v] \gets cc$  \COMMENT{set $v$'s connected-component \# since this is the first time visiting $v$.}
\STATE $Visited(v) \gets 1$
\FORALL[We can access edges in this manner due to algorithm $\ref{alg:dfs_und}$'s adjacency-list requirement on $G$.]{$(v, w) \in E$} 
\IF{$\neg Visited(w)$}
	\STATE $Explore(w)$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Finding Paths}
We need to find paths in an un-directed graph before moving to directed graphs. To do this, we simply track a predecessor vertex when we first visit a vertex.

\begin{algorithm}
	\caption{$DFS(G)$ with path tracking.}
	\begin{algorithmic}[1]
		\REQUIRE $G$ is an un-directed graph in adjacency-list form.
		\STATE $cc \gets 0$
		\FORALL{$v \in V$}
		\STATE $Visited(v) \gets 0$
		\STATE $Prev[v] \gets NIL$
		\ENDFOR
		\FORALL{$v \in V$}
		\IF{$\neg Visited(v)$}
		\STATE $cc \gets cc + 1$
		\STATE $Explore(v)$
		\ENDIF
		\ENDFOR
	\end{algorithmic}
	Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}[H]
	\caption{$Explore(v)$ with path tracking.}
	\begin{algorithmic}[1]
		\REQUIRE $v \in V, E \text{ edges in } G$.
		\STATE $ccnum[v] \gets cc$ 
		\STATE $Visited(v) \gets 1$
		\FORALL{$(v, w) \in E$} 
		\IF{$\neg Visited(w)$}
		\STATE $Explore(w)$
		\STATE $Prev[w] \gets v$
		\ENDIF
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\subsection{Connected components, directed graphs}
\begin{definition}{$clock$}
A global counter incremented during pre and post-order vertex visits.
\end{definition}

Similar approach as section $\ref{cc_und}$, except when visiting a vertex $v$: 
\begin{enumerate}
\item Assign $v$ a pre-order number on initial visit.
\item Increment $clock$.
\item Assign $v$ a post-order number after visiting all of its neighbors.
\item Increment $clock$.
\end{enumerate}
We no longer need to manage $ccnum$.

\begin{remark}
	Only the post-order number is used for connectivity algorithms. Not sure why we're tracking
	pre-order numbers (hint, trick exam questions).
\end{remark}

\begin{algorithm}
\label{alg:dfs_dir}
\caption{$DFS(G)$ for directed graphs.}
\begin{algorithmic}[1]
\REQUIRE $G$ is a directed graph in adjacency-list form.
\STATE $clock \gets 1$ \COMMENT{initializing the global clock}
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
\STATE $Explore(v)$
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}
\caption{$Explore(v)$ for directed graphs.}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\STATE$Pre[v] \gets clock$ \COMMENT{set $v$'s pre-order \#}
\STATE $clock \gets clock + 1$
\STATE $Visited(v) \gets 1$
\FORALL{$(v, w) \in E$} 
\IF{$\neg Visited(w)$}
\STATE $Explore(w)$
\STATE $Post[v] \gets clock$ \COMMENT{set $v$'s post-order \# now that we've traversed its forest}
\STATE $clock \gets clock + 1$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Types of Edges}
Tree, forward, and cross edges in general will have the following clock ordering for some $(z,w) \in E$: $$Post(z) > Post(w)$$ Back edges will have this clock ordering:

$$Post(z) < Post(w)$$ This leads us to our first lemma:
\begin{lemma}
\label{cycle}
	A graph $G$ has a cycle $\iff DFS(G)$ has a back-edge.
\end{lemma}

See \href{https://classroom.udacity.com/courses/ud401/lessons/10159691481/concepts/101975518340923}{this lecture} for concrete examples. 

\begin{lemma}
\label{containment}
For any nodes $u$ and $v$, intervals $[ Pre(u), Post(u) ]$ and $[Pre(v), Post(v)]$ are either disjoint, or one is contained in the other.
\end{lemma}

\subsection{Minimum Spanning Tree}
\begin{definition}
	A tree is a connected, acyclic graph.
	\begin{enumerate}
		\item A tree on $n$ vertices has $n-1$ edges.
		\item In a tree, $\exists$ only one path between every pair of vertices.
		\item Any connected graph with $|E|=|V|-1$ is a tree.
	\end{enumerate}
\end{definition}

\begin{definition}
A spanning tree $F \subseteq E$, is a minimal-weight, connected component s.t.:
\begin{enumerate}
	\item $F$ is acyclic. 
	\item $F$ has $|V|-1=n-1$ edges.
\end{enumerate}
\end{definition}

\subsubsection{Problem}
Given an undirected graph $G = (V,E)$ with weight function $w(e),\: \forall e \in E$, find the spanning tree of minimal weight. 

Given some tree $T \subset E$, we want to minimize the weight sum: $$w(T) = \sum_{e \in T}w(e)$$.

\begin{algorithm}
	\caption{$Kruskals(G)$: finds the MST of $G$.}
	\label{alg:kruskals}
	\begin{algorithmic}[1]
		\REQUIRE $G=(V,E)$ is an undirected graph with weights $w(e), \: \forall e \in E$.
		\STATE Sort $E$ by increasing weights. \COMMENT{Sort using, e.g. merge-sort.}
		\STATE $X \gets \{\}$
		\FORALL {$e \in E$}
		\IF {$X \cup e$ doesn't have a cycle,}
			\STATE $X = X \cup e$
		\ENDIF
		\ENDFOR
		\RETURN $X$
	\end{algorithmic}
\end{algorithm}

Kruskal's algorithm runs in $O(|E|log(|V|))$ if using $MergeSort$, which runs in $O(|E|log(|V|))$ to sort $E$. How do we determine if $X \cup e$ doesn't contain a cycle? 

\begin{lemma}
	Let $comp(v), \: v \in (V,X)$ be a function that returns the component containing $v$. $X$ is what is returned from algorithm \ref{alg:kruskals}. Given edge $(u,v) \in (V,X)$, we know:
	$$comp(u) \neq comp(v) \to X \cup e \text{ doesn't have a cycle.}$$
	This is possible in $O(log|V|)$ time if using the \href{https://en.wikipedia.org/wiki/Disjoint-set_data_structure}{union-find data structure}.
\end{lemma}

\subsection{Max-Flow}
\begin{definition}{Flow Networks}
\label{def:flow_networks}

A directed graph, $G = (V, E, s, t, c)$. Where $s, t$ is the source vertex $s \in V$ and sink vertex $t \in V$ and capacity function $c:E \to \mathbb{N}$.
\end{definition}


\begin{definition}{Flow of an edge, $f_e$}
\label{prop:flow_edge}
	
A function, $f:E \to \mathbb{N}$, representing the flow along an edge, $e \in E$ satisfying \ref{prop:capacity} and \ref{prop:conservation}.
\end{definition}

\begin{definition}{$size(f)$}
\label{prop:size}
	
Flow size represents the total flow of the network and has a useful property:
	
$$\text{Total flow out of } s = \text{Total flow into } t$$
	
given $(s, t)$ are the source and sink vertices in \ref{def:flow_networks}. TODO: verify this is equivalent to $|f|$.
\end{definition}

\begin{definition}{Available Capacity}
\label{def:available_cap}

The available capacity at some $e \in E$ is:
$$c_e - f_e$$
\end{definition}

\begin{definition}{Flow-in to $v$}
\label{def:flowin}
$$\sum_{\overrightarrow{wv} \in E}{f_{wv}}$$
\end{definition}

\begin{definition}{Flow-out of $v$}
\label{def:flowout}
$$\sum_{\overrightarrow{vz} \in E}{f_{vz}}$$
\end{definition}

\begin{definition}{$\text{Capacity constraint}$}
\label{prop:capacity}
$$\forall e \in E, \, 0 \leq f_e \leq c_e$$
\end{definition}

\begin{definition}{$\text{Conservation of flow}$}
\label{prop:conservation}

Given source and sink node $(s,t) \in E$:
$$\forall v \in V - \{s \cup t\}, \, \text{flow-in to } v = \text{flow-out of } v$$ 
\end{definition}

\begin{definition}{$\mathcal{P}$}
\label{prop:cal_p}	

	$\mathcal{P}$ is a path between $(s,t) \in G^f$ with some available capacity, $\ref{def:available_cap}$. Remember, $G^f$ is \textit{built} based on \ref{residual_net}. I.e., $\mathcal{P}$ is an $f$-augmenting \textit{st-path} $\in G^f$
\end{definition}

\subsubsection{Problem}
The Max-Flow problem is: given a flow network, $G$, find $f$ that maximizes $size(f)$, \ref{prop:size}.

\subsubsection{Algorithm Idea}
\begin{algorithm}
\caption{$NaiveMaxFlow$}
\label{alg:naive_max_flow}
\begin{algorithmic}[1]
	\STATE Initialize flow network, $f$: $f_e = 0, \, \forall e \in E$
	\STATE Find some $\mathcal{P}$ \COMMENT{Can use $DFS$ or $BFS$ for this}
	\WHILE {$\exists \mathcal{P}$}
		\STATE $c(\mathcal{P}) \gets \min_{\forall e \in \mathcal{P}} (c_e-f_e)$
		\STATE Augment $f$ by $c(\mathcal{P})$ along $\mathcal{P}$
	\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsubsection{Residual Network, $G^f$}
\label{residual_net}
$G^f$ is useful for finding the max-flow because it lets us augment $f$ with back-edges. It is related to the original, network graph $G$:

$$G^f = (V, E^f)$$

There are constraints to be met before adding an edge $e \in E$ to $E^f$. The first is for forward edges:

$$\overrightarrow{vw} \in E \land f_{vw} < c_{vw} \to \text{ add } \overrightarrow{vw} \text { to } E^f \text { with capacity } c_{vw} - f_{vw}$$

and for back-edges:

$$\overrightarrow{vw} \in E \land f_{vw} > 0 \to \text{ add } \overrightarrow{wv} \text { to } E^f \text { with capacity } f_{vw}$$

\begin{remark}
The reason we do not want anti-parallel edges is because if $G$ had some, we could not construct $G^f$ with forward and back-edges as noted in \ref{residual_net}.
\end{remark}

\begin{algorithm}[H]
\caption{$FordFulkerson$}
\label{alg:ford_fulk}
\begin{algorithmic}[1]
	\REQUIRE $c : E \to \mathbb{N}$ \COMMENT{This is a crucial limitation for $FordFulkerson$ to work}
	\STATE Initialize flow network, $f$: $f_e = 0, \, \forall e \in E$
	\WHILE {$\exists \mathcal{P} \in G^f$}
		\STATE Find $\mathcal{P}$
		\STATE $c(\mathcal{P}) \gets \text{the minimum capacity along } \mathcal{P}$
		\STATE Augment $f$ by $c(\mathcal{P})$ unit along $\mathcal{P}$
	\ENDWHILE
	\RETURN {$f$}
\end{algorithmic}
\end{algorithm}

In \ref{alg:ford_fulk}, we augment by increasing flow along forward edges by $c(\mathcal{P})$, and decreasing flow by $c(\mathcal{P})$ for back-edges. 

\textbf{Correctness}

The proof-of-correctness relies on the max-flow = min-cut theorem, \ref{thm:maxflowmincut}. 

\textbf{Time Complexity}

Due to the requirement in \ref{alg:ford_fulk}, the flow will increase by $\geq 1$ unit per round. How do we determine how many rounds then? Let $C=$ size of max flow. Given that the flow must increase by $\geq 1$ per round, then we know there are $\leq C$ rounds. 

It takes $O(|V|)$ time to update $G^f$, and it takes $O(|E|)$ time, assuming $|E| \geq |V|-1$ since $G$ may have multiple cycles, by running $DFS$ or $BFS$ to find $\mathcal{P}$ left in the loop. Augmenting $f$ in the loop is also $O(|V|$, thus the running time is dominated by $O(|E|)$. 

We must take into account that there's $\leq C$ rounds we iterate through, thus the final running time is \textit{pseudo-polynomial} at:

$$O(|E|C)$$

An excellent \href{https://stackoverflow.com/questions/19649026/is-network-flow-pseudo-polynomial-time}{discussion} on what pseudo-polynomial means. \href{https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm#Integral_example}{Worst-case, integral example}.

\subsection{Max-flow = Min-cut}
\begin{lemma}
\label{lem:aug_path}
For a flow, $f^*$: $$\nexists \mathcal{P} \in G^{f^*} \to f^* \text{is a max-flow}$$.
	
Where $\mathcal{P}$ is \ref{prop:cal_p}.
\end{lemma}

\begin{definition}{\textit{st-cut} capacity}
\label{def:st_cut_cap}

Let a \textit{cut} be a partition of $V = L \cup R$. An \textit{st-cut} is a cut s.t. $s \in L, t \in R$. The capacity from $L$ to $R$ is calculated as:

$$\sum_{\overrightarrow{vw} \in E : v \in L, w \in R} c_{vw}$$
\end{definition}

\begin{claim}
$$size(f) = f^{out} (L) - f^{in} (L)$$

Where $L$ comes from some \textit{st-cut} via \ref{def:st_cut_cap}.
\end{claim}
\begin{proof}

\end{proof}

\begin{theorem}{Max-flow = Min-cut}
\label{thm:maxflowmincut}

I.e., the size of max-flow = the minimum capacity of some \textit{st-cut}.
\end{theorem}

\begin{proof}

\end{proof}

\end{document}
