\documentclass{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{hyperref}
\usepackage[parfill]{parskip}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}[section]
\newtheorem{eg}{Example}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}{Remark}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\begin{document}	
\tableofcontents
\listofalgorithms
\section{Graphs}
\subsection{Connected components, un-directed graphs}
\label{cc_und}

\begin{definition}{$ccnum$}
The number of current, connected components being explored. Each $v \in V$ has a $ccnum$, which is the connected component for that vertex. It may be accessed or assigned via:
$$cc[v]$$
\end{definition}

\begin{algorithm}
\caption{$DFS(G)$: Given vertices $V$ in graph $G$, find all strongly connected components.}
\label{alg:dfs_und}
\begin{algorithmic}[1]
\REQUIRE $G$ is an un-directed graph in adjacency-list form.
\STATE $ccnum \gets 0$
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
	\STATE $ccnum \gets ccnum + 1$
	\STATE $Explore(v)$
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}[H]
\caption{$Explore(v)$}
\label{alg:dfs_und_exp}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\STATE $cc[z] \gets ccnum$  \COMMENT{set $z$'s connected-component \# since this is the first time visiting $v$.}
\STATE $Visited(v) \gets 1$
\FORALL[We can access edges in this manner due to algo. $\ref{alg:dfs_und}$'s adjacency-list requirement on $G$.]{$(v, w) \in E$} 
\IF{$\neg Visited(w)$}
	\STATE $Explore(w)$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Finding Paths}
We need to find paths in an un-directed graph before moving to directed graphs. To do this, we simply track a predecessor vertex when we first visit a vertex.

\begin{algorithm}
	\caption{$DFS(G)$ with path tracking.}
	\begin{algorithmic}[1]
		\REQUIRE $G$ is an un-directed graph in adjacency-list form.
		\STATE $ccnum \gets 0$
		\FORALL{$v \in V$}
		\STATE $Visited(v) \gets 0$
		\STATE $Prev[v] \gets NIL$
		\ENDFOR
		\FORALL{$v \in V$}
		\IF{$\neg Visited(v)$}
		\STATE $ccnum \gets ccnum + 1$
		\STATE $Explore(v)$
		\ENDIF
		\ENDFOR
	\end{algorithmic}
	Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}[H]
	\caption{$Explore(v)$ with path tracking.}
	\begin{algorithmic}[1]
		\REQUIRE $v \in V, E \text{ edges in } G$.
		\STATE $cc[z] \gets ccnum$  \COMMENT{set $z$'s connected-component \# since this is the first time visiting $v$.}
		\STATE $Visited(v) \gets 1$
		\FORALL[We can access edges in this manner due to algo. $\ref{alg:dfs_und}$'s adjacency-list requirement on $G$.]{$(v, w) \in E$} 
		\IF{$\neg Visited(w)$}
		\STATE $Explore(w)$
		\STATE $Prev[w] \gets z$
		\ENDIF
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\subsection{Connected components, directed graphs}
Similar approach as section $\ref{cc_und}$, except when visiting a vertex $v$: 
\begin{enumerate}
\item Assign $v$ a pre-order number on initial visit.
\item Increment $ccnum$.
\item Assign $v$ a post-order number after visiting all of its neighbors.
\item Increment $ccnum$.
\end{enumerate}
We no longer need to track $cc$ and $ccnum$.

\begin{remark}
	Only the post-order number is used for connectivity algorithms. Not sure why we're tracking
	pre-order numbers (hint, trick exam questions).
\end{remark}

\begin{definition}{$clock$}
A global clock counter incremented during pre and post-order vertex visits.
\end{definition}

\begin{algorithm}
\label{alg:dfs_dir}
\caption{$DFS(G)$ for directed graphs.}
\begin{algorithmic}[1]
\REQUIRE $G$ is a directed graph in adjacency-list form.
\STATE $clock \gets 1$ \COMMENT{initializing the global clock}
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
\STATE $Explore(v)$
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}
\caption{$Explore(v)$ for directed graphs.}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\STATE$Pre[v] \gets clock$ \COMMENT{set $v$'s pre-order \#}
\STATE $clock \gets clock + 1$
\STATE $Visited(v) \gets 1$
\FORALL{$(v, w) \in E$} 
\IF{$\neg Visited(w)$}
\STATE $Explore(w)$
\STATE $Post[v] \gets clock$ \COMMENT{set $v$'s post-order \# now that we've traversed its forest}
\STATE $clock \gets clock + 1$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Types of Edges}
Tree, forward, and cross edges in general will have the following clock ordering for some $(z,w) \in E$: $$Post(z) > Post(w)$$ Back edges will have this clock ordering:

$$Post(z) < Post(w)$$ This leads us to our first lemma:
\begin{lemma}
\label{cycle}
	A graph $G$ has a cycle $\iff DFS(G)$ has a back-edge.
\end{lemma}

See \href{https://classroom.udacity.com/courses/ud401/lessons/10159691481/concepts/101975518340923}{this lecture} for concrete examples. 

\subsection{Minimum Spanning Tree}
\begin{definition}
A spanning tree is a connected sub-graph of minimal size.
\end{definition}
\begin{definition}
A tree is a connected, acyclic graph.

\begin{enumerate}
\item A tree on $n$ vertices has $n-1$ edges.
\item In a tree, $\exists$ only one path between every pair of vertices.
\item Any connected graph with $|E|=|V|-1$ is a tree.
\end{enumerate}
\end{definition}

\subsubsection{Problem}
Given an undirected graph $G = (V,E)$ with weight function $w(e),\: \forall e \in E$, find the spanning tree of minimal weight. 

Given some tree $T \subset E$, minimum weight is defined as $$w(T) = \sum_{e \in T}w(e)$$.

\end{document}