\documentclass{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[parfill]{parskip}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}[section]
\newtheorem{claim}[theorem]{Claim}
\newtheorem{eg}{Example}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}{Remark}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\begin{document}	
\tableofcontents
\listofalgorithms
\section{Graphs}

\begin{definition}{Components}
	A component can be thought of as sub-graphs, where any two vertices are connected via a path. Components may have cycles. A graph that is itself connected has exactly one component.
	\href{https://en.wikipedia.org/wiki/Component_(graph_theory)}{Wiki}. 
\end{definition}

\subsection{Connected components, un-directed graphs}
\label{cc_und}

\begin{definition}{$cc$}
The number of current, connected component being explored. Each $v \in V$ belongs to a connected component identified by $cc$. It may be accessed or assigned via:
$$ccnum[v]$$
\end{definition}

\begin{algorithm}[H]
\caption{$DFS(G)$: Given vertices $V$ in graph $G$, find all strongly connected components.}
\label{alg:dfs_und}
\begin{algorithmic}[1]
\REQUIRE $G$ is an un-directed graph in adjacency-list form.
\STATE $cc \gets 0$
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
	\STATE $cc \gets cc + 1$
	\STATE $Explore(v)$ \COMMENT{Each time $Explore$ is called, a new connected component is picked out.}
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}[H]
\caption{$Explore(v)$: identifies the connected component containing $v$.}
\label{alg:dfs_und_exp}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\STATE $ccnum[v] \gets cc$  \COMMENT{set $v$'s connected-component \# since this is the first time visiting $v$.}
\STATE $Visited(v) \gets 1$
\FORALL[We can access edges in this manner due to algorithm $\ref{alg:dfs_und}$'s adjacency-list requirement on $G$.]{$(v, w) \in E$} 
\IF{$\neg Visited(w)$}
	\STATE $Explore(w)$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Finding Paths}
We need to find paths in an un-directed graph before moving to directed graphs. To do this, we simply track a predecessor vertex when we first visit a vertex.

\begin{algorithm}
	\caption{$DFS(G)$ with path tracking.}
	\begin{algorithmic}[1]
		\REQUIRE $G$ is an un-directed graph in adjacency-list form.
		\STATE $cc \gets 0$
		\FORALL{$v \in V$}
		\STATE $Visited(v) \gets 0$
		\STATE $Prev[v] \gets NIL$
		\ENDFOR
		\FORALL{$v \in V$}
		\IF{$\neg Visited(v)$}
		\STATE $cc \gets cc + 1$
		\STATE $Explore(v)$
		\ENDIF
		\ENDFOR
	\end{algorithmic}
	Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}[H]
	\caption{$Explore(v)$ with path tracking.}
	\begin{algorithmic}[1]
		\REQUIRE $v \in V, E \text{ edges in } G$.
		\STATE $ccnum[v] \gets cc$ 
		\STATE $Visited(v) \gets 1$
		\FORALL{$(v, w) \in E$} 
		\IF{$\neg Visited(w)$}
		\STATE $Explore(w)$
		\STATE $Prev[w] \gets v$
		\ENDIF
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\subsection{Connected components, directed graphs}
\begin{definition}{$clock$}
A global counter incremented during pre and post-order vertex visits.
\end{definition}

Similar approach as section $\ref{cc_und}$, except when visiting a vertex $v$: 
\begin{enumerate}
\item Assign $v$ a pre-order number on initial visit.
\item Increment $clock$.
\item Assign $v$ a post-order number after visiting all of its neighbors.
\item Increment $clock$.
\end{enumerate}
We no longer need to manage $ccnum$.

\begin{remark}
	Only the post-order number is used for connectivity algorithms. Not sure why we're tracking
	pre-order numbers (hint, trick exam questions).
\end{remark}

\begin{algorithm}
\label{alg:dfs_dir}
\caption{$DFS(G)$ for directed graphs.}
\begin{algorithmic}[1]
\REQUIRE $G$ is a directed graph in adjacency-list form.
\STATE $clock \gets 1$ \COMMENT{initializing the global clock}
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
\STATE $Explore(v)$
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}
\caption{$Explore(v)$ for directed graphs.}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\STATE$Pre[v] \gets clock$ \COMMENT{set $v$'s pre-order \#}
\STATE $clock \gets clock + 1$
\STATE $Visited(v) \gets 1$
\FORALL{$(v, w) \in E$} 
\IF{$\neg Visited(w)$}
\STATE $Explore(w)$
\STATE $Post[v] \gets clock$ \COMMENT{set $v$'s post-order \# now that we've traversed its forest}
\STATE $clock \gets clock + 1$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Types of Edges}
Tree, forward, and cross edges in general will have the following clock ordering for some $(z,w) \in E$: $$Post(z) > Post(w)$$ Back edges will have this clock ordering:

$$Post(z) < Post(w)$$ This leads us to our first lemma:
\begin{lemma}
\label{cycle}
	A graph $G$ has a cycle $\iff DFS(G)$ has a back-edge.
\end{lemma}

See \href{https://classroom.udacity.com/courses/ud401/lessons/10159691481/concepts/101975518340923}{this lecture} for concrete examples. 

\begin{lemma}
\label{containment}
For any nodes $u$ and $v$, intervals $[ Pre(u), Post(u) ]$ and $[Pre(v), Post(v)]$ are either disjoint, or one is contained in the other.
\end{lemma}

\subsection{Minimum Spanning Tree}
\begin{definition}
	A tree is a connected, acyclic graph.
	\begin{enumerate}
		\item A tree on $n$ vertices has $n-1$ edges.
		\item In a tree, $\exists$ only one path between every pair of vertices.
		\item Any connected graph with $|E|=|V|-1$ is a tree.
	\end{enumerate}
\end{definition}

\begin{definition}
A spanning tree $F \subseteq E$, is a minimal-weight, connected component s.t.:
\begin{enumerate}
	\item $F$ is acyclic. 
	\item $F$ has $|V|-1=n-1$ edges.
\end{enumerate}
\end{definition}

\subsubsection{Problem}
Given an undirected graph $G = (V,E)$ with weight function $w(e),\: \forall e \in E$, find the spanning tree of minimal weight. 

Given some tree $T \subset E$, we want to minimize the weight sum: $$w(T) = \sum_{e \in T}w(e)$$.

\begin{algorithm}
	\caption{$Kruskals(G)$: finds the MST of $G$.}
	\label{alg:kruskals}
	\begin{algorithmic}[1]
		\REQUIRE $G=(V,E)$ is an undirected graph with weights $w(e), \: \forall e \in E$.
		\STATE Sort $E$ by increasing weights. \COMMENT{Sort using, e.g. merge-sort.}
		\STATE $X \gets \{\}$
		\FORALL {$e \in E$}
		\IF {$X \cup e$ doesn't have a cycle,}
			\STATE $X = X \cup e$
		\ENDIF
		\ENDFOR
		\RETURN $X$
	\end{algorithmic}
\end{algorithm}

Kruskal's algorithm runs in $O(|E|log(|V|))$ if using $MergeSort$, which runs in $O(|E|log(|V|))$ to sort $E$. How do we determine if $X \cup e$ doesn't contain a cycle? 

\begin{lemma}
	Let $comp(v), \: v \in (V,X)$ be a function that returns the component containing $v$. $X$ is what is returned from algorithm \ref{alg:kruskals}. Given edge $(u,v) \in (V,X)$, we know:
	$$comp(u) \neq comp(v) \implies X \cup e \text{ doesn't have a cycle.}$$
	This is possible in $O(log|V|)$ time if using the \href{https://en.wikipedia.org/wiki/Disjoint-set_data_structure}{union-find data structure}.
\end{lemma}

\subsection{Max-Flow}
\begin{definition}{Flow Networks}
\label{def:flow_networks}

A directed graph, $G = (V, E, s, t, c)$. Where $s, t$ is the source vertex $s \in V$ and sink vertex $t \in V$ and capacity function $c:E \mapsto \mathbb{N}$.
\end{definition}


\begin{definition}{Flow of an edge, $f_e$}
\label{prop:flow_edge}
	
A function, $f:E \mapsto \mathbb{N}$, representing the flow along an edge, $e \in E$ satisfying \ref{prop:capacity} and \ref{prop:conservation}.
\end{definition}

\begin{definition}{$size(f)$}
\label{prop:size}
	
Flow size represents the total flow of the network and has a useful property:
	
$$\text{Total flow out of } s = \text{Total flow into } t$$
	
given $(s, t)$ are the source and sink vertices in \ref{def:flow_networks}.
\end{definition}

\begin{definition}{Available Capacity}
\label{def:available_cap}

The available capacity at some $e \in E$ is:
$$c_e - f_e$$
\end{definition}

\begin{definition}{Saturated edge}
\label{def:sat_edge}

An edge $e \in E$ is \textit{saturated} if $f_e = c_e$.
\end{definition}

\begin{definition}{Flow-in to $v$}
\label{def:flowin}
$$\sum_{\overrightarrow{wv} \in E}{f_{wv}}$$
\end{definition}

\begin{definition}{Flow-out of $v$}
\label{def:flowout}
$$\sum_{\overrightarrow{vz} \in E}{f_{vz}}$$
\end{definition}

\begin{definition}{Feasible flow}
	
	$f$ is a a feasible flow if \ref{prop:capacity} and \ref{prop:conservation} conditions hold.
\end{definition}

\begin{definition}{$\text{Capacity constraint}$}
\label{prop:capacity}
$$\forall e \in E, \, 0 \leq f_e \leq c_e$$
\end{definition}

\begin{definition}{$\text{Conservation of flow}$}
\label{prop:conservation}

Given source and sink node $(s,t) \in E$:
$$\forall v \in V - \{s \cup t\}, \, \text{flow-in to } v = \text{flow-out of } v$$ 
\end{definition}

\begin{definition}{$\mathcal{P}$}
\label{prop:cal_p}	

	$\mathcal{P}$ is a path connecting $(s,t) \in G^f$ with some available capacity $\in f$,  see $\ref{def:available_cap}$. Remember, $G^f$ is \textit{built} based on \ref{residual_net}. I.e., $\mathcal{P}$ is an $f$-augmenting \textit{st-path} $\in G^f$
\end{definition}

\subsubsection{Problem}
The Max-Flow problem is: given a flow network, $G$, find $f$ that maximizes $size(f)$, \ref{prop:size}.

\subsubsection{Algorithm Idea}
\begin{algorithm}
\caption{$NaiveMaxFlow$}
\label{alg:naive_max_flow}
\begin{algorithmic}[1]
	\STATE Initialize flow network, $f$: $f_e = 0, \, \forall e \in E$
	\STATE Find some $\mathcal{P}$ \COMMENT{Can use $DFS$ or $BFS$ for this}
	\WHILE {$\exists \mathcal{P}$}
		\STATE $c(\mathcal{P}) \gets \min_{\forall e \in \mathcal{P}} (c_e-f_e)$
		\STATE Augment $f$ by $c(\mathcal{P})$ along $\mathcal{P}$
	\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsubsection{Residual Network, $G^f$}
\label{residual_net}
$G^f$ is useful for finding the max-flow because it lets us augment $f$ with back-edges. It is related to the original, network graph $G$:

$$G^f = (V, E^f)$$

There are constraints to be met before adding an edge $e \in E$ to $E^f$. The first is for forward edges:

\begin{definition}
\label{def:add_unsat_2_resid}
$$\overrightarrow{vw} \in E \land f_{vw} < c_{vw} \to \text{ add } \overrightarrow{vw} \text { to } E^f \text { with capacity } c_{vw} - f_{vw}$$
\end{definition}

and for back-edges:

\begin{definition}
\label{def:add_back_edge_unsat_2_resid}
$$\overrightarrow{vw} \in E \land f_{vw} > 0 \to \text{ add } \overrightarrow{wv} \text { to } E^f \text { with capacity } f_{vw}$$
\end{definition}

\begin{remark}
The reason we do not want anti-parallel edges is because if $G$ had some, we could not construct $G^f$ with forward and back-edges as noted in \ref{residual_net}.
\end{remark}

\begin{algorithm}[H]
\caption{$FordFulkerson$}
\label{alg:ford_fulk}
\begin{algorithmic}[1]
	\REQUIRE $c : E \to \mathbb{N}$ \COMMENT{This is a crucial limitation for $FordFulkerson$ to work}
	\STATE Initialize flow network, $f$: $f_e = 0, \, \forall e \in E$
	\WHILE {$\exists \mathcal{P} \in G^f$}
		\STATE Find $\mathcal{P}$
		\STATE $c(\mathcal{P}) \gets \text{the minimum capacity along } \mathcal{P}$
		\STATE Augment $f$ by $c(\mathcal{P})$ unit along $\mathcal{P}$
	\ENDWHILE
	\RETURN {$f$}
\end{algorithmic}
\end{algorithm}

In \ref{alg:ford_fulk}, we augment by increasing flow along forward edges by $c(\mathcal{P})$, and decreasing flow by $c(\mathcal{P})$ for back-edges. 

\textbf{Correctness}

The proof-of-correctness relies on the max-flow = min-cut theorem, \ref{thm:maxflowmincut}. 

\textbf{Time Complexity}

Due to the requirement in \ref{alg:ford_fulk}, the flow will increase by $\geq 1$ unit per round. How do we determine how many rounds then? Let $C=$ size of max flow. Given that the flow must increase by $\geq 1$ per round, then we know there are $\leq C$ rounds. 

It takes $O(|V|)$ time to update $G^f$, and it takes $O(|E|)$ time, assuming $|E| \geq |V|-1$ since $G$ may have multiple cycles, by running $DFS$ or $BFS$ to find $\mathcal{P}$ left in the loop. Augmenting $f$ in the loop is also $O(|V|)$, thus the running time is dominated by $O(|E|)$. 

We must take into account that there's $\leq C$ rounds we iterate through, thus the final running time is \textit{pseudo-polynomial} at:

$$O(|E|C)$$

An excellent \href{https://stackoverflow.com/questions/19649026/is-network-flow-pseudo-polynomial-time}{discussion} on what pseudo-polynomial means. \href{https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm#Integral_example}{Worst-case, integral example}.

\subsection{Max-flow = Min-cut}
\begin{lemma}
\label{lem:aug_path}
For a flow, $f^*$: $$\mathcal{P} \notin G^{f^*} \implies f^* \text{is a max-flow}$$
	
Where $\mathcal{P}$ is \ref{prop:cal_p}.
\end{lemma}

\begin{definition}{\textit{st-cut} and its capacity}
\label{def:st_cut_cap}

An \textit{st-cut} is a partition of $V = L \cup R$, s.t. $s \in L, t \in R, L \cap R = \emptyset$. The capacity from $L$ to $R$ is calculated as:

$$c(L,R) = \sum_{\overrightarrow{vw} \in E : v \in L, w \in R} c_{vw}$$
\end{definition}

\begin{claim}
\label{clm:in_out_flow}
For any flow $f$ and any st-cut $(L,R)$:
$$size(f) = f^{out} (L) - f^{in} (L)$$
\end{claim}

\begin{proof}
	\begin{flalign*}
		f^{out}(L) - f^{in}(L) &= \\
		\shortintertext{First term captures flow \textit{out} of $L$, second term captures flow \textit{into} $L$.}
		&= \sum_{\overrightarrow{vw} \in E:v \in L, w \in R}f_{vw} - \sum_{\overrightarrow{wv} \in E:w \in R, v \in L}f_{wv}\\ 
		\shortintertext{We add and subtract a third and fourth term, representing representing the sum of flows \textit{within} $L$.}
		&+ \sum_{\overrightarrow{vw} \in E:v \in L, w \in L}f_{vw} - \sum_{\overrightarrow{wv} \in E:w \in L, v \in L}f_{wv}\\ 
		\shortintertext{The first and third terms above consider edges from $v \in L$ to $R$, plus edges within $L$. Combined together, we have \textit{all edges} out of $v \in L$, represented as the first term below. Similarly, the second and last terms give the total flow \textit{into} $v \in L$.}
		&= \sum_{v \in L} f^{out}(v) - \sum_{v \in L} f^{in}(v)\\ 
		\shortintertext{We tease out vertex $s$ from the two flow summations above and add $f^{out}(s)$ to maintain equivalence. There is no $f^{in}(s)$ term below, because \emph{$s$ never has flow into it.}}
		&= \sum_{v \in L-s}(f^{out}(v) - f^{in}(v)) + f^{out}(s)\\
		\shortintertext{By conservation of flow, \ref{prop:conservation}, the flow summations in and out of $v$ cancel out.}
		&= \sum_{v \in L-s}0 + f^{out}(s)\\
		\shortintertext{By \ref{prop:size}.}
		&= f^{out}(s) = size(f)&
	\end{flalign*}
\end{proof}

\begin{claim}
\label{clm:size_f_star_is_clr}
	For some $f^*$ generated from $FordFulkerson$:
	$$size(f^*) = c(L,R)$$	
\end{claim}

\begin{proof}
Let $f^*$ be a flow without a path $\mathcal{P} \in G^{f^*}$. We now perform an st-cut, $(L, R)$ by definition \ref{def:st_cut_cap}.

Since $f^*$ has no $\mathcal{P} \in G^{f^*}$, we know that sink $t$ \textbf{can't} be reachable from source $s$ in $G^{f^*}$ by \ref{prop:cal_p}. 

We let $L$ be the set of reachable vertices from $s \in G^{f^*}$, and $R = V - L$. From this, we know $s$ must be in $L$ since $s$ can reach itself, and $t$ must be in $R$, since it contains the set of vertices \textit{unreachable} from $s$. 

It follows that $t \notin L$, because if so, $\exists s \rightsquigarrow t$, which contradicts that $f^*$ has no $\mathcal{P} \in G^{f^*}$.

Taking an st-cut $(L,R)$, we derive a few facts:

\begin{enumerate}
	\item $\forall \overrightarrow{vw} \in E : v \in L, w \in R$, $\overrightarrow{vw}$ is a saturated edge. Otherwise, $\overrightarrow{vw} \in G^{f^*}$ by \ref{def:add_unsat_2_resid}, contradicting $\mathcal{P} \notin G^{f^*}$ because $G^{f^*} \cup \overrightarrow{vw} \implies \exists s \rightsquigarrow t$.
	\item Total $f^{out}(L) = c(L,R)$ by \ref{def:available_cap}.
	\item  $\forall \overrightarrow{wv} \in E : w \in R, v \in L$, $f_{wv} = 0$, otherwise its back edge, $\overrightarrow{vw} \in G^{f^*}$ by \ref{def:add_back_edge_unsat_2_resid}, contradicting $\mathcal{P} \notin G^{f^*}$.
	\item Thus, total $f^{in}(L) = 0$.
\end{enumerate}

Now we may conclude \ref{clm:size_f_star_is_clr} from such facts:
\begin{align*}
size(f^*) &=\\
\shortintertext{From claim \ref{clm:in_out_flow},}
f^{out}(L) - f^{in}(L)&=\\
c(L,R)- 0&=\\
c(L,R)
\end{align*}
\end{proof}

\begin{theorem}{Max-flow = Min-cut}
\label{thm:maxflowmincut}

I.e., the size of max-flow = the minimum capacity of some \textit{st-cut}.
\end{theorem}

To prove \ref{thm:maxflowmincut}, we first prove $\text{max-flow} \leq \text{minimum st-cut}$, then we prove the reverse inequality, $\text{max-flow} \geq \text{minimum st-cut}$.

\begin{proof}
	To prove that $$\text{max-flow} \leq \text{minimum st-cut},$$ we can prove an easier, more general property: for any flow $f$ and any st-cut $(L,R)$:
	
	$$size(f) \leq c(L,R) \implies \text{max-flow} \leq \text{minimum st-cut}$$
	
	where, $c(L,R)$ is the capacity defined in \ref{def:st_cut_cap}. The intuition being that the max-flow of $size(f)$ is just a special case of some $size(f)$, and that the minimum $c(L,R)$ is just a special case of finding some $c(L,R)$.
	
	\begin{align*}
		\shortintertext{By claim \ref{clm:in_out_flow}, we know:}
		size(f) = f^{out} (L) - f^{in} (L)\\
		\shortintertext{It's trivial that $f^{in}(L)$ subtracted from $f^{out}(L)$ makes $f^{out}(L)$ smaller:}
		f^{out} (L) - f^{in} (L) \leq f^{out}(L)\\
		\shortintertext{Along every edge $e$ leaving $L$, we know $f_e$ is $\leq c_e$ by \ref{prop:capacity}:} 
		f^{out} (L) - f^{in} (L) \leq f^{out}(L) \leq c(L,R)
	\end{align*}
	Thus the total flow out of $L$ is at most the total capacity of the edges from $L$ to $R$:

	$$f^{out}(L) \leq c(L,R)$$

	We now show the reverse inequality:
	$$\text{max-flow} \geq \text{minimum st-cut}$$
	Rephrased as:
	$$\text{after maximizing over $f$, } size(f) \geq \text{minimal }c(L,R)$$
	To do so, take some $f^*$ produced from the $FordFulkerson$ algorithm. From \ref{lem:aug_path}, we know that $f^*$ is a max-flow. We want to construct an $(L,R)$ from $f^*$ s.t.:
	$$size(f^*) = c(L,R)$$
	How does the above equality imply $\text{max-flow} \geq \text{minimum st-cut}$? Because we know the max $size(f)$ is at least the $size(f^*)$- note that $f^*$ is just \textit{some} flow calculated during the execution of $FordFulkerson$. 
	So, if we maximize over flow $f$:
	$$size(f) \geq size(f^*) = c(L,R)$$
	Now, how does $c(L,R)$ compare to $\text{minimal }c(L,R)$? Obviously, $c(L,R) \geq \text{minimal }c(L,R)$.
	Using the hypothesis above, we now just need to prove the middle equality term of:
	$$\text{maximum } size(f) \geq size(f^*) = c(L,R) \geq \text{minimal }c(L,R)$$
	which we've proved in \ref{clm:in_out_flow}.
\end{proof}

\section{Reductions}
In this section we discuss methods to reduce problems to a form that can be solved by a black-box algorithm such as max-flow.

\begin{definition}{Bipartite graphs}
\ref{def:bipartite_graphs}
	\\In general a bipartite graph $G=(V_1 \cup V_2, E)$ s.t. each edge has one endpoint in $V_1$ and the other in $V_2$.
\end{definition}

\subsection{Perfect Bipartite matching}
An example of this problem is \textit{matchmaking} for couples. Let $G(V,E)$ be an un-directed graph with vertices that are either male ($M \subset V$) or female ($F \subset V$). An edge, $e \in E$ denotes a match between two people, $v \in V$. Is it possible to choose couples s.t. everyone has \textit{exactly one partner}, i.e. a perfect match?

We first need to translate $G$ into the flow-network: $$G'(V,E',s,t,c: E' \mapsto \mathbb{N})$$

Assume $G$ is bipartite and $|M|=|F|$, i.e. even \# of males and females s.t. couples could be formed.

We add a source $s$ node and connect it to all $v \in M$. We then connect all $v \in F$ to a sink node, $t$. This fulfills the $s,t$ node requirement for $G'$.

Then, we set the max-capacity to all $e \in E'$ to 1, i.e. our capacity function is now $c : E' \mapsto 1$.

Now we run $FordFulkerson$, \ref{alg:ford_fulk}, on $G'$ to generate $f^*$. If $|f^*| = $ the total number of possible couples, we have achieved a perfect match.

\textbf{Intuition}: maxing out the capacity to 1 gives us a nice property which allows us to completely saturate some $\mathcal{P}$ in any given iteration of \ref{alg:ford_fulk}. 

Recall from \ref{def:add_back_edge_unsat_2_resid} that only back-edges are added for saturated edges in $G'$, and once we augment along $\mathcal{P}$ in some step, the next build of ${G'}^{f^*}$ will have all back-edges of edges that comprised of $\mathcal{P}$ pre-augmentation. 

Since $G$ is well-formed, from a couples and bipartite perspective, we know that if some $\mathcal{P}$ was augmented, at least one male and female along $\mathcal{P}$ were saturated. By \ref{prop:conservation}, we know the remaining edges along $\mathcal{P}$ are also saturated. 

Thus no other $\mathcal{P'}$, such as a $\mathcal{P}$-overlapping one, can send any more flow across $\mathcal{P}$, otherwise a vertex could receive more flow from more than one vertex (analogous to a person matching with more than one person), which breaks our definition of a couple-matching.

\subsection{Direct Bipartite matching}
\begin{definition}{Matching edges}
\label{def:match_edge}
	\\A \textit{matching}, $M \in G$ is a set of edges with:
	\begin{enumerate}
		\item Pairwise, non-adjacent edges.
		\item Acyclic.
		\item No two edges share a common vertex.
	\end{enumerate}
\end{definition}

\begin{definition}{Covered vertex}
	\label{def:covered_vtx}
	\\A vertex is \textit{covered} by $M$ if it is an endpoint of any $e \in M$.
\end{definition}

\begin{definition}{Alternating path}
	\label{def:alt_path}
	\\A path, $a := u \rightsquigarrow v$, s.t.:
	\begin{enumerate}
		\item $|a|$ is odd.
		\item $u, v$ are non-covered vertices.
		\item $a$'s edges alternate between $M$ and $E-M$.
	\end{enumerate}
\end{definition}

\begin{lemma}
	$M$ is maximal $\iff \nexists$ an alternating path w.r.t. it.
\end{lemma}

\begin{proof}	
	Some observations...:
	\begin{enumerate}
		\item The \# of covered vertices is $2|M|$.
	\end{enumerate}
\end{proof}

\subsection{Hall's theorem}

\subsection{Image segmentation}

\end{document}
