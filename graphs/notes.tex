\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{algorithm}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}[section]
\newtheorem{eg}{Example}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}{Remark}

\begin{document}	
\listofalgorithms
\section{Graphs}
\subsection{Connected components, un-directed graphs}
\label{cc_und}

\begin{algorithm}
\label{alg:dfs_und}
\caption{$DFS(G)$: Given vertices $V$ in graph $G$, find all strongly connected components.}
\begin{algorithmic}[1]
\REQUIRE $G$ is an un-directed graph in adjacency-list form.
\REQUIRE $cc$ is a global connected-component counter.
\STATE $cc \gets 0$
\FORALL{$v \in V$}
\STATE $Visited(v) \gets 0$
\ENDFOR
\FORALL{$v \in V$}
\IF{$\neg Visited(v)$}
	\STATE $cc \gets cc + 1$
	\STATE $Explore(v)$
\ENDIF
\ENDFOR
\end{algorithmic}
 Running time is $O(|V|+|E|)$.
\end{algorithm}

\begin{algorithm}
\caption{$Explore(v)$}
\begin{algorithmic}[1]
\REQUIRE $v \in V, E \text{ edges in } G$.
\REQUIRE $cc$ is a global connected-component counter.
\STATE $ccnum(z) \gets cc$  \COMMENT{Store $z$'s connected-component \# as the current count for the connected-components.}
\STATE $Visited(v) \gets 1$
\FORALL[We can access edges in this manner due to algo. $\ref{alg:dfs_und}$'s adjacency-list requirement on $G$.]{$(v, w) \in E$} 
\IF{$\neg Visited(v)$}
	\STATE $Explore(v)$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Connected components, directed graphs}
Similar approach as section $\ref{cc_und}$, except when visiting a vertex $v$: 
\begin{enumerate}
\item Assign $v$ a pre-order number on initial visit.
\item Increment $cc$.
\item Assign $v$ a post-order number after visiting all of its neighbors.
\item Increment $cc$.
\end{enumerate}


\end{document}